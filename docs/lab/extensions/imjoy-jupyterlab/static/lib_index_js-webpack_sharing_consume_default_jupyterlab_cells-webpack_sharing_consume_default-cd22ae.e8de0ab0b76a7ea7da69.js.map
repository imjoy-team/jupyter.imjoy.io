{"version":3,"file":"lib_index_js-webpack_sharing_consume_default_jupyterlab_cells-webpack_sharing_consume_default-cd22ae.e8de0ab0b76a7ea7da69.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA,AAE8B;AAGA;;AAEkB;;AAEhB;;AAIU;;AAEI;;AAE9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qBAAqB;AAClD;AACA,wBAAwB,+DAAa;AACrC;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAmB;;AAE/B;AACA;AACA;;AAEA;AACA,MAAM,+EAAiC;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO,IAAI,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;;AAEA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iFAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,iFAAmB;AACvB;;AAEA;AACA,IAAI,oFAAsB;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA,QAAQ,iFAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iFAAmB;AAC3B;AACA;AACA;AACA;AACA;;AAEA,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,mDAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,gBAAgB,6CAA6C;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,0BAA0B;AACtE;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,mDAAM;AAC/B;AACA;AACA;AACA,uBAAuB,mDAAM;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kEAAkE,gBAAgB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,EAAE;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sBAAsB,kDAAK;AAC3B;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA,CAAC","sources":["webpack://imjoy-jupyterlab/./lib/index.js"],"sourcesContent":["/**\n * A notebook widget extension that adds a button to the toolbar.\n */\n import {\n  ToolbarButton\n} from '@jupyterlab/apputils';\nimport {\n  DisposableDelegate\n} from '@phosphor/disposable';\n\nimport { Widget, Panel } from '@lumino/widgets';\n\nimport OpenAI from 'openai-api';\n\nimport {\n  NotebookActions\n} from '@jupyterlab/notebook/lib/actions';\n\nimport { ElementExt } from '@lumino/domutils';\n\nfunction capitalize(s)\n{\n    return s && s[0].toUpperCase() + s.slice(1);\n}\n\nconst promptPrefix = `# Generate code for Jupyter notebooks\nI start with an empty jupyter notebook with Python 3 kernel, and incrementally add instructions for each cell. The instructions are comment string starts with \"##\" (with additional details are provided as quoted with \"\"\") the lines after the instructions or details should be a generated executable Python 3 code block or empty.\nThe instructions are given by a human via a speech-to-text program in a noisy environment, therefore the text maybe confusing and requires correction but the general context is using python for data analysis.\nThe result of each code block should be printed or displayed in the notebook.\n\nIn the following cases, it should generate a special command string instead of a python code block:\n - To cancel or undo last cell, generate \"%undo\"\n - To execute all the cells, generate \"%run-all\"\n - To execute the current or active cell, generate \"%run\"\n`\nclass NotebookExtension {\n   /**\n    * Create a new extension object.\n    */\n   createNew(panel, context) {\n     const notebook = panel.content\n      let callback = () => {\n          this.notebook = notebook;\n          this.sessionContext = context.sessionContext;\n          // enable the previous button and disable the current one\n          if(this.button) this.button.enabled = true;\n          button.enabled = false;\n          this.button = button;\n          alert(`Notebook \"${notebook.title.label}\" is now activated as the current chat notebook!`)\n       };\n       let button = new ToolbarButton({\n         iconClass: 'jp-MaterialIcon jp-LinkIcon',\n         onClick: callback,\n         tooltip: 'Make this notebook as the current chat notebook'\n       });\n       if(!this.notebook){\n        // enable the previous button and disable the current one\n        if(this.button) this.button.enabled = true;\n          button.enabled = false;\n          this.button = button;\n          this.notebook = notebook;\n          this.sessionContext = context.sessionContext;\n       }\n        \n       panel.toolbar.insertItem(0, 'activate', button);\n     \n     return new DisposableDelegate(() => {\n        button.dispose();\n        this.button = null;\n        this.notebook = null;\n        this.sessionContext = null;\n        this.lastCellNumber = null;\n        this.lastCellIndex = null;\n     });\n   }\n\n    /**\n   * Get the state of a widget before running an action.\n   */\n  getState(notebook) {\n    return {\n      wasFocused: notebook.node.contains(document.activeElement),\n      activeCell: notebook.activeCell\n    };\n  }\n\n  /**\n   * Handle the state of a widget after running an action.\n   */\n  handleState(\n    notebook,\n    state,\n    scrollIfNeeded = false\n  ) {\n    const { activeCell, node } = notebook;\n\n    if (state.wasFocused || notebook.mode === 'edit') {\n      notebook.activate();\n    }\n\n    if (scrollIfNeeded && activeCell) {\n      ElementExt.scrollIntoViewIfNeeded(node, activeCell.node);\n    }\n  }\n\n   getCodeHistory(){\n    const cells = this.notebook.model.cells;\n    const history = [];\n    let firstMarkdown = true;\n    for (let i = 0; i < cells.length; i++) {\n      if(i>this.notebook.activeCellIndex) break;\n      const cell = cells.get(i);\n      if (cell.type === 'code') {\n        history.push(cell.value.text)\n      }\n      else if (cell.type === 'markdown') {\n        const text = cell.value.text;\n        let newText = \"\";\n        // add ## before each line in the text\n        const lines = text.split('\\n');\n        newText += '## ' + lines[0].replace(/^(\\#+\\s)/,\"\");\n        \n        if(firstMarkdown || lines.length>1){\n          let details, prefix;\n          if(firstMarkdown){\n            prefix = promptPrefix;\n            firstMarkdown = false;\n          }\n          else prefix = \"\";\n  \n          if(lines.length>1) details = lines.slice(1).join('\\n');\n          else details = \"\";\n  \n          newText += `\\n\"\"\"\\n${prefix}\\n${details}\\n\"\"\"`;\n        }\n        // remove leading # and add ##\n        // newText = lines.map(line => '## ' + line.replace(/^(\\#+\\s)/,\"\")).join('\\n');\n        history.push(newText)\n      }\n    }\n    return history\n   }\n\n   addCell(doc, code) {\n    const notebook = this.notebook;\n    if (!notebook.model || !notebook.activeCell) {\n      return;\n    }\n    const state = this.getState(notebook);\n    const model = notebook.model;\n    // \n    \n    const docCell = model.contentFactory.createMarkdownCell({});\n    docCell.value.text = doc\n    model.cells.insert(notebook.activeCellIndex + 1, docCell);\n\n    const codeCell = model.contentFactory.createCodeCell({});\n    codeCell.value.text = code // 'print(\"hello world\")'\n    model.cells.insert(notebook.activeCellIndex + 2, codeCell);\n    notebook.activeCellIndex+=2;\n    this.lastCellIndex = notebook.activeCellIndex\n    this.lastCellNumber = 2\n\n    notebook.deselectAll();\n    this.handleState(notebook, state, true);\n    setTimeout(async ()=>{\n      // Try to execute the cell\n      try{\n        const ret = await NotebookActions.run(this.notebook, this.sessionContext)\n        console.log(ret)\n      }\n      catch(e){\n        console.error(e)\n      }\n      \n    },0)\n   }\n\n   addMarkdown(markdown){\n    const notebook = this.notebook;\n    if (!notebook.model || !notebook.activeCell) {\n      return;\n    }\n    const state = this.getState(notebook);\n    const docCell = model.contentFactory.createMarkdownCell({});\n    docCell.value.text = markdown\n    model.cells.insert(notebook.activeCellIndex + 1, docCell);\n    notebook.activeCellIndex+=1;\n    this.lastCellIndex = notebook.activeCellIndex\n    this.lastCellNumber = 1\n    notebook.deselectAll();\n    this.handleState(notebook, state, true);\n   }\n\n   runCell(){\n    NotebookActions.run(this.notebook, this.sessionContext)\n   }\n\n   runAllCells(){\n    NotebookActions.runAll(this.notebook, this.sessionContext)\n   }\n\n   undoCell(){\n     let returned_text = \"\"\n     \n     \n     if(this.lastCellNumber && this.lastCellNumber > 0){\n       for(let i=0;i<this.lastCellNumber;i++){\n        const cell = this.notebook.model.cells.get(this.notebook.activeCellIndex);\n         // obtain the content if it's a comment cell\n        if(cell && cell.type === 'markdown' && cell.value.text.trim().startsWith('# ')){\n          returned_text = cell.value.text.trim().replace(/^(\\#+\\s)/,\"\");\n         }\n        NotebookActions.cut(this.notebook)\n        this.notebook.activeCellIndex = this.lastCellIndex - (this.lastCellNumber - 1)\n       }\n        this.lastCellIndex = 0\n        this.lastCellNumber = 0\n     }\n     else{\n        const cell = this.notebook.model.cells.get(this.notebook.activeCellIndex);\n        // obtain the content if it's a comment cell\n        if(cell && cell.type === 'markdown' && cell.value.text.trim().startsWith('# ')){\n          returned_text = cell.value.text.trim().replace(/^(\\#+\\s)/,\"\");\n        }\n        NotebookActions.cut(this.notebook)\n        this.notebook.activeCellIndex -=1;\n     }\n      return returned_text\n   }\n}\n\nexport default {\n  id: 'imjoy-jupyterlab',\n  autoStart: true,\n  activate: function (app) {\n    console.log(\n      'JupyterLab extension imjoy-jupyterlab is activated!'\n    );\n    console.log(app.commands);\n    const nbExt = new NotebookExtension()\n    app.docRegistry.addWidgetExtension('Notebook', nbExt);\n\n    class ContentWidget extends Widget {\n      constructor() {\n          super();\n          this.addClass('content'); \n          this.id = 'tutorial'\n          this.title.label = 'Codex Chat Notebook'\n          this.title.closable = true;\n          this.createNode()\n      }\n\n      setupSpeech(){\n        if (\"webkitSpeechRecognition\" in window) {\n          let speechRecognition = new webkitSpeechRecognition();\n          let final_transcript = \"\";\n          let started = false;\n          // const colors = [ 'aqua' , 'azure' , 'beige', 'bisque', 'black', 'blue', 'brown', 'chocolate', 'coral', 'segment', 'cells' ];\n          // const grammar = '#JSGF V1.0; grammar colors; public <color> = ' + colors.join(' | ') + ' ;'\n          // var speechRecognitionList = new SpeechGrammarList();\n          // speechRecognitionList.addFromString(grammar, 1);\n          // speechRecognition.grammars = speechRecognitionList;\n          speechRecognition.continuous = true;\n          speechRecognition.interimResults = true;\n          speechRecognition.lang = 'en-US';\n          this.speechButton.style.background = \"\";\n        \n          speechRecognition.onstart = () => {\n            started = true;\n            final_transcript = '';\n            this.speechButton.style.background = \"LightGoldenRodYellow\";\n          };\n          speechRecognition.onerror = () => {\n            started = false;\n            this.speechButton.style.background = \"red\";\n            console.log(\"Speech Recognition Error\");\n          };\n          speechRecognition.onend = () => {\n            started = false;\n            this.speechButton.style.background = \"\";\n            console.log(\"Speech Recognition Ended\");\n          };\n        \n          speechRecognition.onresult = (event) => {\n            let interim_transcript = \"\";\n        \n            for (let i = event.resultIndex; i < event.results.length; ++i) {\n              if (event.results[i].isFinal) {\n                final_transcript += event.results[i][0].transcript;\n                this.inputBox.value = final_transcript;\n              } else {\n                interim_transcript += event.results[i][0].transcript;\n                this.inputBox.value = interim_transcript;\n              }\n            }\n          };\n          this.speechRecognition = speechRecognition;\n          this.speechButton.onclick = () => {\n            if (started) {\n              speechRecognition.stop();\n            }\n            else{\n              speechRecognition.start();\n            }\n          };\n        } else {\n          console.error(\"Speech Recognition Not Available\");\n          this.speechButton.style.display = \"none\";\n        }\n      }\n\n      createNode() {\n        this.node.innerHTML = `<h2>Chat Notebook</h2><p>Built with OpenAI GPT-3 and Codex, by Wei Ouyang</p>`\n        this.node.style.padding = \"10px\"\n        this.node.style.background = \"white\";\n        this.node.style.height = \"100%\";\n        this.node.style.overflow = \"auto\";\n        this.tokenInput = document.createElement('input')\n        this.tokenInput.style.display = \"block\";\n        this.tokenInput.style.width = \"100%\";\n        this.tokenInput.style.color = \"gray\";\n        this.tokenInput.type = \"password\";\n        this.inputBox = document.createElement('textarea')\n        this.inputBox.style.marginTop = \"10px\";\n        this.inputBox.style.display = \"block\";\n        this.inputBox.style.width = \"100%\";\n        this.inputBox.style.height = \"6rem\";\n        this.inputBox.style.fontSize = \"16px\";\n        this.speechButton = document.createElement('button')\n        this.speechButton.innerHTML = 'Voice'\n        this.speechButton.style.width = \"50%\";\n        this.speechButton.style.height = \"20px\";\n        this.speechButton.style.fontSize = \"16px\";\n        this.speechButton.style.display = \"inline-block\";\n        this.speechButton.classList.add(\"bp3-button\", \"bp3-minimal\", \"jp-ToolbarButtonComponent\", \"minimal\", \"jp-Button\")\n        this.undoButton = document.createElement('button')\n        this.undoButton.style.width = \"50%\";\n        this.undoButton.style.height = \"20px\";\n        this.undoButton.style.fontSize = \"16px\";\n        this.undoButton.innerHTML = 'Undo'\n        this.undoButton.style.display = \"inline-block\";\n        this.undoButton.classList.add(\"bp3-button\", \"bp3-minimal\", \"jp-ToolbarButtonComponent\", \"minimal\", \"jp-Button\")\n        this.executeButton = document.createElement('button')\n        this.executeButton.innerHTML = 'Execute'\n        this.executeButton.style.display = \"block\";\n        this.executeButton.style.fontSize = \"16px\";\n        this.executeButton.style.width = \"100%\";\n        this.executeButton.classList.add(\"bp3-button\", \"bp3-minimal\", \"jp-ToolbarButtonComponent\", \"minimal\", \"jp-Button\")\n       \n        this.node.appendChild(this.tokenInput)\n        this.node.appendChild(this.inputBox)\n        this.node.appendChild(this.speechButton)\n        this.node.appendChild(this.undoButton)\n        this.node.appendChild(this.executeButton)\n        \n        this.requestedCodeElm = document.createElement('pre')\n        this.requestedCodeElm.style.color = 'gray'\n        this.respondCodeElm = document.createElement('pre')\n        this.respondCodeElm.style.color = 'blue'\n        this.node.appendChild(this.respondCodeElm)\n        this.node.appendChild(this.requestedCodeElm)\n\n        let openai;\n        const lastToken = localStorage.getItem('openai-token');\n        if (lastToken) {\n            openai = new OpenAI(lastToken);\n            this.tokenInput.value = lastToken;\n        }\n        this.tokenInput.onchange = () => {\n          openai = new OpenAI(this.tokenInput.value);\n          localStorage.setItem('openai-token', this.tokenInput.value);\n        }\n\n        this.executeButton.onclick = async () => {\n          this.respondCodeElm.innerHTML = \"\"\n          if(this.speechRecognition) this.speechRecognition.stop();\n          const command = capitalize(this.inputBox.value.trim())\n          if(command.length <=0) return;\n          const lines = command.split('\\n');\n\n          let formatedCommand = '## ' + lines[0].replace(/^(\\#+\\s)/,\"\");\n          if(lines.length>1) formatedCommand += '\\n\"\"\"\\n' + lines.slice(1).join('\\n') + '\\n\"\"\"' \n          const prompt = nbExt.getCodeHistory().join('\\n') + `\\n${formatedCommand}\\n`\n          this.requestedCodeElm.innerHTML = prompt\n          this.executeButton.style.background = \"LightGoldenRodYellow\";\n          try{\n            const gptResponse = await openai.complete({\n              engine: 'davinci-codex',\n              prompt,\n              maxTokens: 500,\n              temperature: 0.1,\n              topP: 1,\n              presencePenalty: 0,\n              frequencyPenalty: 0,\n              bestOf: 1,\n              n: 1,\n              stream: false,\n              stop: ['## ']\n            });\n            console.log(gptResponse.data);\n            const completion = gptResponse.data.choices[0].text.trim()\n            this.respondCodeElm.innerHTML = completion\n            if(completion.startsWith('%undo')){\n              this.undoButton.onclick();\n            }\n            else if(completion.startsWith('%run')){\n              nbExt.runCell()\n            }\n            else if(completion.startsWith('%run-all')){\n              nbExt.runAllCells()\n            }\n            else if(completion.startsWith('%markdown')){\n              // remove the %markdown from the completion\n              const markdown = completion.substring(10)\n              nbExt.addMarkdown(markdown)\n            }\n            else{\n              nbExt.addCell(\"# \" + command.trim(), completion)\n            }\n          }\n          catch(e){\n            console.error(e)\n            alert(`Failed to execute: ${e}`)\n          }\n          this.executeButton.style.background = \"\";\n          this.inputBox.value = '';\n        }\n        this.undoButton.onclick = async () => {\n          if(this.speechRecognition) this.speechRecognition.stop();\n          if(this.inputBox.value.trim().length>0){\n            this.inputBox.value = '';\n            return;\n          }\n          else{\n            const lastMarkdownCellContent = nbExt.undoCell()\n            this.inputBox.value = lastMarkdownCellContent.split('\\n')[0];\n          }\n        }\n        this.inputBox.addEventListener('keydown', (e)=>{\n          if (e.key == 'Enter' && !e.shiftKey) {\n            this.executeButton.onclick();\n            e.preventDefault();\n          }\n        });\n        this.setupSpeech()\n      }\n    }\n    const panel = new Panel();\n    panel.id = 'Example-tab';\n    panel.title.iconClass = 'jp-MaterialIcon jp-LinkIcon';\n    panel.addWidget(new ContentWidget());\n    app.shell.add(panel, 'left', { rank: 1 })\n  }\n}\n\n"],"names":[],"sourceRoot":""}